# Partitioned Chain Detector Deployment
#
# This docker-compose file implements ADR-003 (Partitioned Chain Detectors)
# using the UnifiedChainDetector service with partition-based configuration.
#
# Partitions:
# - partition-asia-fast: BSC + Polygon + Avalanche + Fantom (asia-southeast1, heavy resources)
# - partition-l2-turbo: Arbitrum + Optimism + Base (asia-southeast1, standard resources)
# - partition-high-value: Ethereum + zkSync + Linea (us-east1, heavy resources)
# - partition-solana: Solana (us-west1, heavy resources)
#
# ============================================================================
# REQUIRED Environment Variables (create .env file or export before running):
# ============================================================================
# Partition asia-fast (BSC + Polygon + Avalanche + Fantom):
#   BSC_WS_URL        - WebSocket URL for BSC (e.g., wss://bsc.example.com)
#   BSC_RPC_URL       - RPC URL for BSC (e.g., https://bsc.example.com)
#   POLYGON_WS_URL    - WebSocket URL for Polygon
#   POLYGON_RPC_URL   - RPC URL for Polygon
#   AVALANCHE_WS_URL  - WebSocket URL for Avalanche
#   AVALANCHE_RPC_URL - RPC URL for Avalanche
#   FANTOM_WS_URL     - WebSocket URL for Fantom
#   FANTOM_RPC_URL    - RPC URL for Fantom
#
# Partition l2-turbo (Arbitrum + Optimism + Base):
#   ARBITRUM_WS_URL  - WebSocket URL for Arbitrum
#   ARBITRUM_RPC_URL - RPC URL for Arbitrum
#   OPTIMISM_WS_URL  - WebSocket URL for Optimism
#   OPTIMISM_RPC_URL - RPC URL for Optimism
#   BASE_WS_URL      - WebSocket URL for Base
#   BASE_RPC_URL     - RPC URL for Base
#
# Partition high-value (Ethereum + zkSync + Linea):
#   ETHEREUM_WS_URL  - WebSocket URL for Ethereum
#   ETHEREUM_RPC_URL - RPC URL for Ethereum
#   ZKSYNC_WS_URL    - WebSocket URL for zkSync Era
#   ZKSYNC_RPC_URL   - RPC URL for zkSync Era
#   LINEA_WS_URL     - WebSocket URL for Linea
#   LINEA_RPC_URL    - RPC URL for Linea
#
# Execution Engine (private keys - KEEP SECURE):
#   ETHEREUM_PRIVATE_KEY - Private key for Ethereum transactions
#   BSC_PRIVATE_KEY      - Private key for BSC transactions
#   ARBITRUM_PRIVATE_KEY - Private key for Arbitrum transactions
#   BASE_PRIVATE_KEY     - Private key for Base transactions
#   POLYGON_PRIVATE_KEY  - Private key for Polygon transactions
#   OPTIMISM_PRIVATE_KEY - Private key for Optimism transactions
#
# Usage:
#   1. Copy .env.example to .env and fill in values
#   2. docker-compose -f docker-compose.partition.yml up -d
#
# @see ADR-003: Partitioned Chain Detectors
# @see REFACTORING_ROADMAP.md Phase 2

version: '3.8'

services:
  # =============================================================================
  # Infrastructure Services
  # =============================================================================

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped

  # =============================================================================
  # Partitioned Chain Detectors (ADR-003)
  # =============================================================================

  # Partition: asia-fast (BSC + Polygon + Avalanche + Fantom)
  # Region: asia-southeast1, Provider: oracle, Profile: heavy
  partition-asia-fast:
    build:
      context: ../..
      dockerfile: services/unified-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=asia-fast
      - PARTITION_CHAINS=bsc,polygon,avalanche,fantom
      - REGION_ID=asia-southeast1
      - INSTANCE_ID=partition-asia-fast-${HOSTNAME:-local}
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Chain-specific RPC URLs (REQUIRED - no defaults, will fail if not set)
      - BSC_WS_URL=${BSC_WS_URL:?BSC_WS_URL is required}
      - BSC_RPC_URL=${BSC_RPC_URL:?BSC_RPC_URL is required}
      - POLYGON_WS_URL=${POLYGON_WS_URL:?POLYGON_WS_URL is required}
      - POLYGON_RPC_URL=${POLYGON_RPC_URL:?POLYGON_RPC_URL is required}
      - AVALANCHE_WS_URL=${AVALANCHE_WS_URL:?AVALANCHE_WS_URL is required}
      - AVALANCHE_RPC_URL=${AVALANCHE_RPC_URL:?AVALANCHE_RPC_URL is required}
      - FANTOM_WS_URL=${FANTOM_WS_URL:?FANTOM_WS_URL is required}
      - FANTOM_RPC_URL=${FANTOM_RPC_URL:?FANTOM_RPC_URL is required}
    ports:
      - "3011:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 768M
          cpus: '1.0'
        reservations:
          memory: 384M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=asia-fast"
      - "com.arbitrage.chains=bsc,polygon,avalanche,fantom"
      - "com.arbitrage.region=asia-southeast1"
      - "com.arbitrage.profile=heavy"

  # Partition: l2-turbo (Arbitrum + Optimism + Base)
  # Region: asia-southeast1, Provider: fly, Profile: standard
  partition-l2-turbo:
    build:
      context: ../..
      dockerfile: services/unified-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=l2-turbo
      - PARTITION_CHAINS=arbitrum,optimism,base
      - REGION_ID=asia-southeast1
      - INSTANCE_ID=partition-l2-turbo-${HOSTNAME:-local}
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Chain-specific RPC URLs (REQUIRED - no defaults, will fail if not set)
      - ARBITRUM_WS_URL=${ARBITRUM_WS_URL:?ARBITRUM_WS_URL is required}
      - ARBITRUM_RPC_URL=${ARBITRUM_RPC_URL:?ARBITRUM_RPC_URL is required}
      - OPTIMISM_WS_URL=${OPTIMISM_WS_URL:?OPTIMISM_WS_URL is required}
      - OPTIMISM_RPC_URL=${OPTIMISM_RPC_URL:?OPTIMISM_RPC_URL is required}
      - BASE_WS_URL=${BASE_WS_URL:?BASE_WS_URL is required}
      - BASE_RPC_URL=${BASE_RPC_URL:?BASE_RPC_URL is required}
    ports:
      - "3012:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.75'
        reservations:
          memory: 256M
          cpus: '0.25'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 10s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=l2-turbo"
      - "com.arbitrage.chains=arbitrum,optimism,base"
      - "com.arbitrage.region=asia-southeast1"
      - "com.arbitrage.profile=standard"

  # Partition: high-value (Ethereum + zkSync + Linea)
  # Region: us-east1, Provider: oracle, Profile: heavy
  partition-high-value:
    build:
      context: ../..
      dockerfile: services/unified-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=high-value
      - PARTITION_CHAINS=ethereum,zksync,linea
      - REGION_ID=us-east1
      - INSTANCE_ID=partition-high-value-${HOSTNAME:-local}
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Chain-specific RPC URLs (REQUIRED - no defaults, will fail if not set)
      - ETHEREUM_WS_URL=${ETHEREUM_WS_URL:?ETHEREUM_WS_URL is required}
      - ETHEREUM_RPC_URL=${ETHEREUM_RPC_URL:?ETHEREUM_RPC_URL is required}
      - ZKSYNC_WS_URL=${ZKSYNC_WS_URL:?ZKSYNC_WS_URL is required}
      - ZKSYNC_RPC_URL=${ZKSYNC_RPC_URL:?ZKSYNC_RPC_URL is required}
      - LINEA_WS_URL=${LINEA_WS_URL:?LINEA_WS_URL is required}
      - LINEA_RPC_URL=${LINEA_RPC_URL:?LINEA_RPC_URL is required}
    ports:
      - "3013:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 768M
          cpus: '1.0'
        reservations:
          memory: 384M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=high-value"
      - "com.arbitrage.chains=ethereum,zksync,linea"
      - "com.arbitrage.region=us-east1"
      - "com.arbitrage.profile=heavy"

  # Partition: solana-native (Solana)
  # Region: us-west1, Provider: fly, Profile: heavy
  # NOTE: Solana is non-EVM and requires dedicated connection handling
  partition-solana:
    build:
      context: ../..
      dockerfile: services/partition-solana/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=solana-native
      - PARTITION_CHAINS=solana
      - REGION_ID=us-west1
      - INSTANCE_ID=partition-solana-${HOSTNAME:-local}
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Solana RPC URLs (REQUIRED - no defaults, will fail if not set)
      - SOLANA_RPC_URL=${SOLANA_RPC_URL:?SOLANA_RPC_URL is required}
      - SOLANA_WS_URL=${SOLANA_WS_URL:?SOLANA_WS_URL is required}
    ports:
      - "3016:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '1.0'
        reservations:
          memory: 256M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 10s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=solana-native"
      - "com.arbitrage.chains=solana"
      - "com.arbitrage.region=us-west1"
      - "com.arbitrage.profile=heavy"

  # =============================================================================
  # Cross-Chain Analysis & Execution Services
  # =============================================================================

  # Cross-Chain Detector (consumes from all partitions via Redis Streams)
  cross-chain-detector:
    build:
      context: ../..
      dockerfile: services/cross-chain-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - INSTANCE_ID=cross-chain-detector-${HOSTNAME:-local}
      - HEALTH_CHECK_PORT=3001
    ports:
      - "3014:3001"
    depends_on:
      redis:
        condition: service_healthy
      partition-asia-fast:
        condition: service_healthy
      partition-l2-turbo:
        condition: service_healthy
      partition-high-value:
        condition: service_healthy
      partition-solana:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 384M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped

  # Execution Engine
  execution-engine:
    build:
      context: ../..
      dockerfile: services/execution-engine/Dockerfile
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - INSTANCE_ID=execution-engine-${HOSTNAME:-local}
      - HEALTH_CHECK_PORT=3001
      # Private keys for each chain (required for execution)
      - ETHEREUM_PRIVATE_KEY=${ETHEREUM_PRIVATE_KEY}
      - BSC_PRIVATE_KEY=${BSC_PRIVATE_KEY}
      - ARBITRUM_PRIVATE_KEY=${ARBITRUM_PRIVATE_KEY}
      - BASE_PRIVATE_KEY=${BASE_PRIVATE_KEY}
      - POLYGON_PRIVATE_KEY=${POLYGON_PRIVATE_KEY}
      - OPTIMISM_PRIVATE_KEY=${OPTIMISM_PRIVATE_KEY}
    ports:
      - "3015:3001"
    depends_on:
      redis:
        condition: service_healthy
      cross-chain-detector:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped

  # =============================================================================
  # Dashboard & Monitoring
  # =============================================================================

  # Coordinator Dashboard
  coordinator:
    build:
      context: ../..
      dockerfile: services/coordinator/Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - PORT=3000
      - INSTANCE_ID=coordinator-${HOSTNAME:-local}
      # Cross-region health configuration
      - REGION_ID=${COORDINATOR_REGION:-us-east1}
      - ENABLE_CROSS_REGION_HEALTH=true
    depends_on:
      redis:
        condition: service_healthy
      partition-asia-fast:
        condition: service_healthy
      partition-l2-turbo:
        condition: service_healthy
      partition-high-value:
        condition: service_healthy
      cross-chain-detector:
        condition: service_healthy
      execution-engine:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
    networks:
      - arbitrage-network
    restart: unless-stopped

# =============================================================================
# Networks & Volumes
# =============================================================================

networks:
  arbitrage-network:
    driver: bridge

volumes:
  redis_data:
    driver: local
