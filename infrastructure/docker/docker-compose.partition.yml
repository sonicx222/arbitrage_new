# Partitioned Chain Detector Deployment
#
# This docker-compose file implements ADR-003 (Partitioned Chain Detectors)
# using the UnifiedChainDetector service with partition-based configuration.
#
# Partitions:
# - partition-asia-fast: BSC + Polygon + Avalanche + Fantom (asia-southeast1, heavy resources)
# - partition-l2-turbo: Arbitrum + Optimism + Base + Scroll + Blast (asia-southeast1, standard resources)
# - partition-high-value: Ethereum + zkSync + Linea (us-east1, heavy resources)
# - partition-solana: Solana (us-west1, heavy resources)
#
# ============================================================================
# REQUIRED Environment Variables (create .env file or export before running):
# ============================================================================
# Partition asia-fast (BSC + Polygon + Avalanche + Fantom):
#   BSC_WS_URL        - WebSocket URL for BSC (e.g., wss://bsc.example.com)
#   BSC_RPC_URL       - RPC URL for BSC (e.g., https://bsc.example.com)
#   POLYGON_WS_URL    - WebSocket URL for Polygon
#   POLYGON_RPC_URL   - RPC URL for Polygon
#   AVALANCHE_WS_URL  - WebSocket URL for Avalanche
#   AVALANCHE_RPC_URL - RPC URL for Avalanche
#   FANTOM_WS_URL     - WebSocket URL for Fantom
#   FANTOM_RPC_URL    - RPC URL for Fantom
#
# Partition l2-turbo (Arbitrum + Optimism + Base + Scroll + Blast):
#   ARBITRUM_WS_URL  - WebSocket URL for Arbitrum
#   ARBITRUM_RPC_URL - RPC URL for Arbitrum
#   OPTIMISM_WS_URL  - WebSocket URL for Optimism
#   OPTIMISM_RPC_URL - RPC URL for Optimism
#   BASE_WS_URL      - WebSocket URL for Base
#   BASE_RPC_URL     - RPC URL for Base
#   SCROLL_WS_URL    - WebSocket URL for Scroll
#   SCROLL_RPC_URL   - RPC URL for Scroll
#   BLAST_WS_URL     - WebSocket URL for Blast
#   BLAST_RPC_URL    - RPC URL for Blast
#
# Partition high-value (Ethereum + zkSync + Linea):
#   ETHEREUM_WS_URL  - WebSocket URL for Ethereum
#   ETHEREUM_RPC_URL - RPC URL for Ethereum
#   ZKSYNC_WS_URL    - WebSocket URL for zkSync Era
#   ZKSYNC_RPC_URL   - RPC URL for zkSync Era
#   LINEA_WS_URL     - WebSocket URL for Linea
#   LINEA_RPC_URL    - RPC URL for Linea
#
# Execution Engine (private keys - KEEP SECURE):
#   ETHEREUM_PRIVATE_KEY - Private key for Ethereum transactions
#   BSC_PRIVATE_KEY      - Private key for BSC transactions
#   ARBITRUM_PRIVATE_KEY - Private key for Arbitrum transactions
#   BASE_PRIVATE_KEY     - Private key for Base transactions
#   POLYGON_PRIVATE_KEY  - Private key for Polygon transactions
#   OPTIMISM_PRIVATE_KEY - Private key for Optimism transactions
#
# Usage:
#   1. Copy .env.example to .env and fill in values
#   2. docker-compose -f docker-compose.partition.yml up -d
#
# @see ADR-003: Partitioned Chain Detectors
# @see REFACTORING_ROADMAP.md Phase 2

# =============================================================================
# FIX L8: Platform Compatibility Notes
# =============================================================================
# This configuration is tested on linux/amd64. If deploying on linux/arm64
# (e.g., AWS Graviton, Apple Silicon, Oracle Ampere):
#
# 1. All Node.js images support arm64 natively — no changes needed.
# 2. redis:7-alpine supports arm64 natively.
# 3. If using platform-specific native modules (e.g., bcrypt), ensure the
#    Dockerfile uses multi-stage builds that compile on the target arch.
# 4. To force a platform: add `platform: linux/amd64` to individual services
#    or use `docker buildx build --platform linux/arm64` for cross-compilation.
#
# See: https://docs.docker.com/compose/compose-file/05-services/#platform
# =============================================================================

services:
  # =============================================================================
  # Infrastructure Services
  # =============================================================================

  # Redis uses inline flags here (Docker deployment).
  # For Oracle Cloud ARM deployments, see oracle/redis/redis-production.conf
  # which adds io-threads, slowlog, dangerous command disabling, and 512mb memory.
  #
  # Redis maxmemory per deployment tier:
  #   docker-compose.yml (dev/base):         256mb
  #   docker-compose.partition.yml (prod):   256mb
  #   docker-compose.testnet.yml:            128mb
  #   oracle/redis-production.conf (ARM):    512mb (24GB host, headroom for AOF rewrite)
  #   cloud-init-partition (Oracle ARM):     512mb
  #   cloud-init-cross-chain (Oracle AMD):   256mb (1/8 OCPU micro instance)
  redis:
    image: redis:7-alpine
    ports:
      - "127.0.0.1:6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru --requirepass ${REDIS_PASSWORD:?REDIS_PASSWORD must be set}
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD:?REDIS_PASSWORD must be set}", "--no-auth-warning", "ping"]
      # FIX P3-1: Standardize to 15s interval per ADR-007 (was 10s)
      # Consistent with docker-compose.yml and health-check.sh default
      interval: 15s
      timeout: 10s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped

  # =============================================================================
  # Partitioned Chain Detectors (ADR-003)
  # =============================================================================

  # Partition: asia-fast (BSC + Polygon + Avalanche + Fantom)
  # Region: asia-southeast1, Provider: oracle, Profile: heavy
  partition-asia-fast:
    build:
      context: ../..
      dockerfile: services/unified-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=asia-fast
      - PARTITION_CHAINS=bsc,polygon,avalanche,fantom
      - REGION_ID=asia-southeast1
      - INSTANCE_ID=partition-asia-fast-${HOSTNAME:-local}
      - REDIS_URL=redis://:${REDIS_PASSWORD:?REDIS_PASSWORD must be set}@redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Chain-specific RPC URLs (REQUIRED - no defaults, will fail if not set)
      - BSC_WS_URL=${BSC_WS_URL:?BSC_WS_URL is required}
      - BSC_RPC_URL=${BSC_RPC_URL:?BSC_RPC_URL is required}
      - POLYGON_WS_URL=${POLYGON_WS_URL:?POLYGON_WS_URL is required}
      - POLYGON_RPC_URL=${POLYGON_RPC_URL:?POLYGON_RPC_URL is required}
      - AVALANCHE_WS_URL=${AVALANCHE_WS_URL:?AVALANCHE_WS_URL is required}
      - AVALANCHE_RPC_URL=${AVALANCHE_RPC_URL:?AVALANCHE_RPC_URL is required}
      - FANTOM_WS_URL=${FANTOM_WS_URL:?FANTOM_WS_URL is required}
      - FANTOM_RPC_URL=${FANTOM_RPC_URL:?FANTOM_RPC_URL is required}
    ports:
      - "3011:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 768M
          cpus: '1.0'
        reservations:
          memory: 384M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=asia-fast"
      - "com.arbitrage.chains=bsc,polygon,avalanche,fantom"
      - "com.arbitrage.region=asia-southeast1"
      - "com.arbitrage.profile=heavy"

  # Partition: l2-turbo (Arbitrum + Optimism + Base + Scroll + Blast)
  # Region: asia-southeast1, Provider: fly, Profile: standard
  # Scroll and Blast are fully operational with real DEX addresses (per CLAUDE.md).
  # Mantle and Mode remain stubs — config present but missing verified DEX factories.
  partition-l2-turbo:
    build:
      context: ../..
      dockerfile: services/unified-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=l2-turbo
      - PARTITION_CHAINS=arbitrum,optimism,base,scroll,blast
      - REGION_ID=asia-southeast1
      - INSTANCE_ID=partition-l2-turbo-${HOSTNAME:-local}
      - REDIS_URL=redis://:${REDIS_PASSWORD:?REDIS_PASSWORD must be set}@redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Chain-specific RPC URLs (REQUIRED - no defaults, will fail if not set)
      - ARBITRUM_WS_URL=${ARBITRUM_WS_URL:?ARBITRUM_WS_URL is required}
      - ARBITRUM_RPC_URL=${ARBITRUM_RPC_URL:?ARBITRUM_RPC_URL is required}
      - OPTIMISM_WS_URL=${OPTIMISM_WS_URL:?OPTIMISM_WS_URL is required}
      - OPTIMISM_RPC_URL=${OPTIMISM_RPC_URL:?OPTIMISM_RPC_URL is required}
      - BASE_WS_URL=${BASE_WS_URL:?BASE_WS_URL is required}
      - BASE_RPC_URL=${BASE_RPC_URL:?BASE_RPC_URL is required}
      - SCROLL_WS_URL=${SCROLL_WS_URL:?SCROLL_WS_URL is required}
      - SCROLL_RPC_URL=${SCROLL_RPC_URL:?SCROLL_RPC_URL is required}
      - BLAST_WS_URL=${BLAST_WS_URL:?BLAST_WS_URL is required}
      - BLAST_RPC_URL=${BLAST_RPC_URL:?BLAST_RPC_URL is required}
    ports:
      - "3012:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 640M
          cpus: '0.75'
        reservations:
          memory: 320M
          cpus: '0.25'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      # FIX P1-1: Standardize to 15s interval per ADR-007 (was 10s)
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=l2-turbo"
      - "com.arbitrage.chains=arbitrum,optimism,base,scroll,blast"
      - "com.arbitrage.region=asia-southeast1"
      - "com.arbitrage.profile=standard"

  # Partition: high-value (Ethereum + zkSync + Linea)
  # Region: us-east1, Provider: oracle, Profile: heavy
  partition-high-value:
    build:
      context: ../..
      dockerfile: services/unified-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=high-value
      - PARTITION_CHAINS=ethereum,zksync,linea
      - REGION_ID=us-east1
      - INSTANCE_ID=partition-high-value-${HOSTNAME:-local}
      - REDIS_URL=redis://:${REDIS_PASSWORD:?REDIS_PASSWORD must be set}@redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Chain-specific RPC URLs (REQUIRED - no defaults, will fail if not set)
      - ETHEREUM_WS_URL=${ETHEREUM_WS_URL:?ETHEREUM_WS_URL is required}
      - ETHEREUM_RPC_URL=${ETHEREUM_RPC_URL:?ETHEREUM_RPC_URL is required}
      - ZKSYNC_WS_URL=${ZKSYNC_WS_URL:?ZKSYNC_WS_URL is required}
      - ZKSYNC_RPC_URL=${ZKSYNC_RPC_URL:?ZKSYNC_RPC_URL is required}
      - LINEA_WS_URL=${LINEA_WS_URL:?LINEA_WS_URL is required}
      - LINEA_RPC_URL=${LINEA_RPC_URL:?LINEA_RPC_URL is required}
    ports:
      - "3013:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 768M
          cpus: '1.0'
        reservations:
          memory: 384M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      # FIX P1-1: Standardize to 15s interval per ADR-007 (was 30s)
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=high-value"
      - "com.arbitrage.chains=ethereum,zksync,linea"
      - "com.arbitrage.region=us-east1"
      - "com.arbitrage.profile=heavy"

  # Partition: solana-native (Solana)
  # Region: us-west1, Provider: fly, Profile: heavy
  # NOTE: Solana is non-EVM and requires dedicated connection handling
  partition-solana:
    build:
      context: ../..
      dockerfile: services/partition-solana/Dockerfile
    environment:
      - NODE_ENV=production
      - PARTITION_ID=solana-native
      - PARTITION_CHAINS=solana
      - REGION_ID=us-west1
      - INSTANCE_ID=partition-solana-${HOSTNAME:-local}
      - REDIS_URL=redis://:${REDIS_PASSWORD:?REDIS_PASSWORD must be set}@redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - HEALTH_CHECK_PORT=3001
      - ENABLE_CROSS_REGION_HEALTH=true
      # Solana RPC URLs (REQUIRED - no defaults, will fail if not set)
      - SOLANA_RPC_URL=${SOLANA_RPC_URL:?SOLANA_RPC_URL is required}
      - SOLANA_WS_URL=${SOLANA_WS_URL:?SOLANA_WS_URL is required}
    ports:
      # FIX H2: Was 3016, corrected to 3014 (local port 3004 + 10 offset)
      - "3014:3001"
    depends_on:
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '1.0'
        reservations:
          memory: 256M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      # FIX P1-1: Standardize to 15s interval per ADR-007 (was 10s)
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped
    labels:
      - "com.arbitrage.partition=solana-native"
      - "com.arbitrage.chains=solana"
      - "com.arbitrage.region=us-west1"
      - "com.arbitrage.profile=heavy"

  # =============================================================================
  # Cross-Chain Analysis & Execution Services
  # =============================================================================

  # Cross-Chain Detector (consumes from all partitions via Redis Streams)
  cross-chain-detector:
    build:
      context: ../..
      dockerfile: services/cross-chain-detector/Dockerfile
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://:${REDIS_PASSWORD:?REDIS_PASSWORD must be set}@redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - INSTANCE_ID=cross-chain-detector-${HOSTNAME:-local}
      - HEALTH_CHECK_PORT=3001
    ports:
      # FIX H2: Was 3014, corrected to 3016 (local port 3006 + 10 offset)
      - "3016:3001"
    depends_on:
      redis:
        condition: service_healthy
      partition-asia-fast:
        condition: service_healthy
      partition-l2-turbo:
        condition: service_healthy
      partition-high-value:
        condition: service_healthy
      partition-solana:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 384M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped

  # Execution Engine
  execution-engine:
    build:
      context: ../..
      dockerfile: services/execution-engine/Dockerfile
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://:${REDIS_PASSWORD:?REDIS_PASSWORD must be set}@redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - INSTANCE_ID=execution-engine-${HOSTNAME:-local}
      - HEALTH_CHECK_PORT=3001
      # Private keys for each chain (required for execution)
      - ETHEREUM_PRIVATE_KEY=${ETHEREUM_PRIVATE_KEY}
      - BSC_PRIVATE_KEY=${BSC_PRIVATE_KEY}
      - ARBITRUM_PRIVATE_KEY=${ARBITRUM_PRIVATE_KEY}
      - BASE_PRIVATE_KEY=${BASE_PRIVATE_KEY}
      - POLYGON_PRIVATE_KEY=${POLYGON_PRIVATE_KEY}
      - OPTIMISM_PRIVATE_KEY=${OPTIMISM_PRIVATE_KEY}
    ports:
      - "3015:3001"
    depends_on:
      redis:
        condition: service_healthy
      cross-chain-detector:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped

  # =============================================================================
  # Dashboard & Monitoring
  # =============================================================================

  # Coordinator Dashboard
  coordinator:
    build:
      context: ../..
      dockerfile: services/coordinator/Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://:${REDIS_PASSWORD:?REDIS_PASSWORD must be set}@redis:6379
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - PORT=3000
      - INSTANCE_ID=coordinator-${HOSTNAME:-local}
      # Cross-region health configuration
      - REGION_ID=${COORDINATOR_REGION:-us-east1}
      - ENABLE_CROSS_REGION_HEALTH=true
    depends_on:
      redis:
        condition: service_healthy
      partition-asia-fast:
        condition: service_healthy
      partition-l2-turbo:
        condition: service_healthy
      partition-high-value:
        condition: service_healthy
      partition-solana:
        condition: service_healthy
      cross-chain-detector:
        condition: service_healthy
      execution-engine:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
    healthcheck:
      # Coordinator uses Express with '/api' prefix — health endpoint is /api/health
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3000/api/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
      interval: 15s
      timeout: 10s
      start_period: 30s
      retries: 3
    networks:
      - arbitrage-network
    restart: unless-stopped

# =============================================================================
# Networks & Volumes
# =============================================================================

networks:
  arbitrage-network:
    driver: bridge

volumes:
  redis_data:
    driver: local
