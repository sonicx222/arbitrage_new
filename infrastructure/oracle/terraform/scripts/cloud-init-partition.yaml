#cloud-config
# Cloud-init configuration for Arbitrage Partition Service
#
# This script bootstraps an Oracle Cloud instance to run a partition detector
#
# @see ADR-003: Partitioned Chain Detectors
# @see ADR-006: Free Hosting Provider Selection

package_update: true
package_upgrade: true

packages:
  - docker
  - docker-compose
  - git
  - curl
  - jq

write_files:
  - path: /opt/arbitrage/docker-compose.yml
    permissions: '0644'
    content: |
      version: '3.8'
      services:
        partition:
          image: ${docker_image}
          restart: unless-stopped
          ports:
            - "${health_port}:3001"
          environment:
            - NODE_ENV=production
            - PARTITION_ID=${partition_id}
            - PARTITION_CHAINS=${chains}
            - REGION_ID=${region_id}
            - INSTANCE_ID=oracle-${partition_id}-$${HOSTNAME}
            - REDIS_URL=${redis_url}
            - LOG_LEVEL=${log_level}
            - HEALTH_CHECK_PORT=3001
            - ENABLE_CROSS_REGION_HEALTH=true
            # Chain-specific RPC URLs (empty string if not used by this partition)
            - BSC_WS_URL=${bsc_ws_url}
            - BSC_RPC_URL=${bsc_rpc_url}
            - POLYGON_WS_URL=${polygon_ws_url}
            - POLYGON_RPC_URL=${polygon_rpc_url}
            - AVALANCHE_WS_URL=${avalanche_ws_url}
            - AVALANCHE_RPC_URL=${avalanche_rpc_url}
            - FANTOM_WS_URL=${fantom_ws_url}
            - FANTOM_RPC_URL=${fantom_rpc_url}
            - ETHEREUM_WS_URL=${ethereum_ws_url}
            - ETHEREUM_RPC_URL=${ethereum_rpc_url}
            - ZKSYNC_WS_URL=${zksync_ws_url}
            - ZKSYNC_RPC_URL=${zksync_rpc_url}
            - LINEA_WS_URL=${linea_ws_url}
            - LINEA_RPC_URL=${linea_rpc_url}
          healthcheck:
            # Use node-based health check (curl not available in Alpine Node images)
            test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/health',r=>{process.exit(r.statusCode===200?0:1)}).on('error',()=>process.exit(1))\""]
            interval: 15s
            timeout: 10s
            retries: 3
            start_period: 30s
          deploy:
            resources:
              limits:
                memory: ${memory_mb}M
                cpus: '1.0'
          logging:
            driver: json-file
            options:
              max-size: "10m"
              max-file: "3"

  - path: /opt/arbitrage/scripts/health-check.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Health check script for partition service

      HEALTH_URL="http://localhost:${health_port}/health"
      MAX_RETRIES=3
      RETRY_DELAY=5

      for i in $(seq 1 $MAX_RETRIES); do
        response=$(curl -s -o /dev/null -w "%%{http_code}" "$HEALTH_URL")
        if [ "$response" = "200" ]; then
          echo "Health check passed"
          exit 0
        fi
        echo "Health check failed (attempt $i/$MAX_RETRIES), retrying in $RETRY_DELAY seconds..."
        sleep $RETRY_DELAY
      done

      echo "Health check failed after $MAX_RETRIES attempts"
      exit 1

  - path: /opt/arbitrage/scripts/restart-service.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Restart the partition service

      cd /opt/arbitrage
      docker-compose pull
      docker-compose down
      docker-compose up -d

      echo "Service restarted at $(date)"

  - path: /etc/systemd/system/arbitrage-partition.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Arbitrage Partition Service
      After=docker.service network-online.target
      Requires=docker.service
      Wants=network-online.target
      # Wait for Docker to be fully ready
      ConditionPathExists=/var/run/docker.sock

      [Service]
      Type=oneshot
      RemainAfterExit=yes
      WorkingDirectory=/opt/arbitrage
      # Ensure Docker is ready before starting
      ExecStartPre=/bin/sleep 5
      ExecStart=/usr/bin/docker-compose up -d
      ExecStop=/usr/bin/docker-compose down
      # NOTE: Restart=on-failure is not effective with Type=oneshot since
      # docker-compose up -d returns 0 immediately. The cron-based health
      # check below handles container restarts instead.

      [Install]
      WantedBy=multi-user.target

  - path: /etc/cron.d/arbitrage-health
    permissions: '0644'
    content: |
      # Health check every 5 minutes, restart if unhealthy
      */5 * * * * root /opt/arbitrage/scripts/health-check.sh || /opt/arbitrage/scripts/restart-service.sh >> /var/log/arbitrage-restart.log 2>&1

runcmd:
  # ==========================================================================
  # Validate required template variables before proceeding
  # ==========================================================================
  - |
    set -e
    LOG_FILE="/var/log/arbitrage-init.log"

    validate_var() {
      local name="$1"
      local value="$2"
      local pattern="$3"

      if [ -z "$value" ]; then
        echo "$(date): ERROR: Required variable $name is empty" >> "$LOG_FILE"
        exit 1
      fi

      if [ -n "$pattern" ]; then
        if ! echo "$value" | grep -qE "$pattern"; then
          echo "$(date): ERROR: Variable $name has invalid format: $value" >> "$LOG_FILE"
          exit 1
        fi
      fi
    }

    echo "$(date): Starting template variable validation..." >> "$LOG_FILE"

    # Validate critical variables with safe patterns
    validate_var "docker_image" "${docker_image}" "^[a-zA-Z0-9][a-zA-Z0-9._/:@-]*$"
    validate_var "partition_id" "${partition_id}" "^[a-zA-Z0-9_-]+$"
    validate_var "region_id" "${region_id}" "^[a-zA-Z0-9_-]+$"
    validate_var "health_port" "${health_port}" "^[0-9]+$"
    validate_var "redis_url" "${redis_url}" "^redis(s)?://"
    validate_var "log_level" "${log_level}" "^(debug|info|warn|error)$"

    # Validate port range (must be non-privileged and valid)
    if [ "${health_port}" -lt 1024 ] || [ "${health_port}" -gt 65535 ]; then
      echo "$(date): ERROR: health_port must be between 1024 and 65535" >> "$LOG_FILE"
      exit 1
    fi

    echo "$(date): All template variables validated successfully" >> "$LOG_FILE"

  # Start and enable Docker
  - systemctl start docker
  - systemctl enable docker

  # Wait for Docker to be fully operational
  - |
    echo "$(date): Waiting for Docker to be ready..." >> /var/log/arbitrage-init.log
    for i in $(seq 1 30); do
      if docker info >/dev/null 2>&1; then
        echo "$(date): Docker is ready" >> /var/log/arbitrage-init.log
        break
      fi
      echo "$(date): Waiting for Docker... attempt $i/30" >> /var/log/arbitrage-init.log
      sleep 2
    done

  # Add opc user to docker group
  - usermod -aG docker opc

  # Create arbitrage directories
  - mkdir -p /opt/arbitrage/scripts
  - mkdir -p /opt/arbitrage/logs

  # Set ownership
  - chown -R opc:opc /opt/arbitrage

  # Pull and start the service with error handling
  - |
    cd /opt/arbitrage
    echo "$(date): Pulling Docker image..." >> /var/log/arbitrage-init.log
    if ! docker-compose pull 2>> /var/log/arbitrage-init.log; then
      echo "$(date): ERROR: Failed to pull Docker image" >> /var/log/arbitrage-init.log
      exit 1
    fi
    echo "$(date): Starting service..." >> /var/log/arbitrage-init.log
    if ! docker-compose up -d 2>> /var/log/arbitrage-init.log; then
      echo "$(date): ERROR: Failed to start service" >> /var/log/arbitrage-init.log
      exit 1
    fi
    echo "$(date): Service started successfully" >> /var/log/arbitrage-init.log

  # Enable systemd service
  - systemctl daemon-reload
  - systemctl enable arbitrage-partition

  # Open firewall for health port
  - firewall-cmd --permanent --add-port=${health_port}/tcp
  - firewall-cmd --reload

  # Log completion
  - echo "Partition ${partition_id} initialized at $(date)" >> /var/log/arbitrage-init.log

final_message: "Arbitrage partition ${partition_id} initialized successfully!"
