# Redis 7 Production Configuration for Arbitrage System
#
# Optimized for self-hosted deployment on Oracle Cloud ARM instances.
# Runs alongside partition services on the same host (localhost access only).
#
# @see docs/reports/DEEP_ENHANCEMENT_ANALYSIS_2026-02-22.md Item #1
# @see ADR-002: Redis Streams architecture
#
# Key optimizations over defaults:
# - AOF persistence with everysec fsync (durability without latency cost)
# - 512MB memory limit (conservative for 24GB ARM instance)
# - allkeys-lru eviction (graceful degradation under memory pressure)
# - Localhost-only binding (security: no external access)
# - TCP keepalive for connection health
# - Disabled dangerous commands in production

# =============================================================================
# Network
# =============================================================================

# Bind to localhost only — services run on the same host
bind 127.0.0.1 -::1

# Default port
port 6379

# TCP backlog (matches Linux default somaxconn)
tcp-backlog 511

# Client timeout: 0 = no timeout (services maintain persistent connections)
timeout 0

# TCP keepalive: detect dead connections every 60s
tcp-keepalive 60

# =============================================================================
# Memory
# =============================================================================

# 512MB memory limit — conservative for 24GB ARM instance
# Services use ~75MB each (8 services = ~600MB), Redis needs headroom for
# Streams data, keys, and copy-on-write during BGSAVE
maxmemory 512mb

# Eviction policy: remove least recently used keys when memory limit reached
# This is safe because the system treats Redis as a cache + stream broker,
# not as primary storage. Stream trimming handles data retention separately.
maxmemory-policy allkeys-lru

# =============================================================================
# Persistence
# =============================================================================

# AOF persistence: append-only file for durability
appendonly yes

# Fsync every second — good balance of durability vs performance
# At most 1 second of data loss on crash (acceptable for arbitrage system
# where the execution engine has its own trade log persistence)
appendfsync everysec

# Allow AOF rewrite during BGSAVE (both are I/O heavy but ARM has 4 OCPUs)
no-appendfsync-on-rewrite no

# Auto-rewrite AOF when it grows 100% beyond last rewrite size
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# RDB snapshots as backup (in addition to AOF)
save 900 1
save 300 10
save 60 10000

# =============================================================================
# Streams (ADR-002)
# =============================================================================

# Stream consumer group tracking uses memory proportional to pending messages.
# With 50:1 batching and ~1000 events/sec, pending count stays manageable.
# Default stream settings are sufficient.

# =============================================================================
# Performance
# =============================================================================

# Lazy freeing: use background threads for large key deletion
lazyfree-lazy-eviction yes
lazyfree-lazy-expire yes
lazyfree-lazy-server-del yes

# I/O threads: use 2 for read/write (ARM has 4 OCPUs, 2 for Redis is generous)
io-threads 2
io-threads-do-reads yes

# =============================================================================
# Security
# =============================================================================

# Password required (set via --requirepass flag in docker-compose)
# requirepass is set via command line, not in config file, to avoid
# storing passwords in version control.

# Disable dangerous commands in production
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command DEBUG ""
rename-command CONFIG "ARBITRAGE_CONFIG"

# Disable KEYS command (use SCAN instead, per code_conventions.md)
rename-command KEYS ""

# =============================================================================
# Logging
# =============================================================================

# Log level: notice (default, appropriate for production)
loglevel notice

# Log to stdout (captured by Docker logging driver)
logfile ""

# =============================================================================
# Slow Log
# =============================================================================

# Log commands slower than 10ms (our hot-path budget is 50ms total)
slowlog-log-slower-than 10000

# Keep last 128 slow log entries
slowlog-max-len 128
