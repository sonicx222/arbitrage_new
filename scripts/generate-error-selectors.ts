/**
 * P3-FIX 4.1 / Phase 5.3: Error Selector Auto-Generation Script
 *
 * Generates error selectors from FlashLoanArbitrage.sol ABI to prevent
 * drift between contract and TypeScript error mappings.
 *
 * Usage:
 *   npx ts-node scripts/generate-error-selectors.ts
 *   npm run generate:error-selectors
 *
 * Output:
 *   services/execution-engine/src/strategies/error-selectors.generated.ts
 *
 * @see base.strategy.ts parseRevertReason() - uses the generated selectors
 */

import * as fs from 'fs';
import * as path from 'path';
import { keccak256, toUtf8Bytes } from 'ethers';

// =============================================================================
// Configuration
// =============================================================================

const ABI_PATH = path.join(
  __dirname,
  '../contracts/artifacts/src/FlashLoanArbitrage.sol/FlashLoanArbitrage.json'
);

const OUTPUT_PATH = path.join(
  __dirname,
  '../services/execution-engine/src/strategies/error-selectors.generated.ts'
);

// =============================================================================
// Types
// =============================================================================

interface AbiItem {
  type: string;
  name?: string;
  inputs?: Array<{ name: string; type: string; internalType?: string }>;
}

interface AbiFile {
  contractName: string;
  abi: AbiItem[];
}

// =============================================================================
// Main
// =============================================================================

function generateErrorSelector(errorName: string, inputs: Array<{ type: string }> = []): string {
  // Build the error signature: ErrorName(type1,type2,...)
  const paramTypes = inputs.map(i => i.type).join(',');
  const signature = `${errorName}(${paramTypes})`;

  // Compute keccak256 hash and take first 4 bytes (8 hex chars + 0x prefix)
  const hash = keccak256(toUtf8Bytes(signature));
  return hash.slice(0, 10); // 0x + 8 hex chars
}

function main(): void {
  console.log('üîß Generating error selectors from FlashLoanArbitrage ABI...\n');

  // Read ABI file
  if (!fs.existsSync(ABI_PATH)) {
    console.error(`‚ùå ABI file not found: ${ABI_PATH}`);
    console.error('   Run `npm run compile` in contracts directory first.');
    process.exit(1);
  }

  const abiFile: AbiFile = JSON.parse(fs.readFileSync(ABI_PATH, 'utf-8'));

  // Extract errors from ABI
  const errors = abiFile.abi.filter(item => item.type === 'error');

  if (errors.length === 0) {
    console.warn('‚ö†Ô∏è  No custom errors found in ABI');
    process.exit(0);
  }

  console.log(`Found ${errors.length} custom errors:\n`);

  // Generate selectors with collision detection
  const selectors: Array<{ selector: string; name: string; signature: string }> = [];
  // FIX P2-2: Track selectors to detect hash collisions (extremely rare but critical for security contracts)
  const selectorMap = new Map<string, { name: string; signature: string }>();

  for (const error of errors) {
    if (!error.name) continue;

    const selector = generateErrorSelector(error.name, error.inputs || []);
    const paramTypes = (error.inputs || []).map(i => i.type).join(',');
    const signature = `${error.name}(${paramTypes})`;

    // FIX P2-2: Check for selector collision
    if (selectorMap.has(selector)) {
      const existing = selectorMap.get(selector)!;
      console.error(`\n‚ùå ERROR: Selector collision detected!`);
      console.error(`   Selector: ${selector}`);
      console.error(`   Error 1:  ${existing.signature}`);
      console.error(`   Error 2:  ${signature}`);
      console.error(`\n   This is extremely rare (1 in 4 billion) but must be fixed in the contract.`);
      console.error(`   Rename one of the errors or change parameter types to resolve the collision.`);
      process.exit(1);
    }

    selectorMap.set(selector, { name: error.name, signature });
    selectors.push({ selector, name: error.name, signature });
    console.log(`  ${selector} => ${error.name}`);
  }

  // Sort by selector for consistent output
  selectors.sort((a, b) => a.selector.localeCompare(b.selector));

  // Generate output file
  const timestamp = new Date().toISOString();
  const output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * Generated by: scripts/generate-error-selectors.ts
 * Generated at: ${timestamp}
 * Contract: ${abiFile.contractName}
 * Source: ${ABI_PATH}
 *
 * To regenerate, run: npm run generate:error-selectors
 *
 * @see base.strategy.ts - parseRevertReason() uses these selectors
 */

// =============================================================================
// Custom Error Selectors
// =============================================================================

/**
 * Mapping of 4-byte error selectors to error names.
 * Selectors are computed as: keccak256(ErrorName(types...)).slice(0, 10)
 */
export const CUSTOM_ERROR_SELECTORS: Record<string, string> = {
${selectors.map(s => `  '${s.selector}': '${s.name}', // ${s.signature}`).join('\n')}
};

/**
 * Reverse mapping: error name to selector
 */
export const ERROR_NAME_TO_SELECTOR: Record<string, string> = {
${selectors.map(s => `  '${s.name}': '${s.selector}',`).join('\n')}
};

/**
 * All known error signatures (for debugging/documentation)
 */
export const ERROR_SIGNATURES: Record<string, string> = {
${selectors.map(s => `  '${s.name}': '${s.signature}',`).join('\n')}
};

/**
 * Check if a selector matches a known custom error
 */
export function isKnownErrorSelector(selector: string): boolean {
  return selector.toLowerCase() in CUSTOM_ERROR_SELECTORS;
}

/**
 * Get error name from selector (returns undefined if not found)
 */
export function getErrorName(selector: string): string | undefined {
  return CUSTOM_ERROR_SELECTORS[selector.toLowerCase()];
}
`;

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write output file
  fs.writeFileSync(OUTPUT_PATH, output, 'utf-8');

  console.log(`\n‚úÖ Generated ${selectors.length} error selectors`);
  console.log(`   Output: ${OUTPUT_PATH}`);
}

// Run if executed directly
main();
