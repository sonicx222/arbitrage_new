/**
 * Execution Engine Service Entry Point
 *
 * Reads standby configuration from environment variables and initializes
 * the execution engine with proper failover settings (ADR-007).
 *
 * Environment Variables:
 * - IS_STANDBY: Whether this instance is a standby (default: false)
 * - QUEUE_PAUSED_ON_START: Whether queue starts paused (default: false)
 * - REGION_ID: Region identifier for this instance (default: 'us-east1')
 * - EXECUTION_SIMULATION_MODE: Whether simulation mode is enabled
 *
 * @see ADR-007: Cross-Region Failover Strategy
 */
import { IncomingMessage, ServerResponse, Server } from 'http';
import { ExecutionEngineService, SimulationConfig } from './engine';
import {
  createLogger,
  getCrossRegionHealthManager,
  resetCrossRegionHealthManager,
  parseEnvInt,
  getCrossRegionEnvConfig,
  setupServiceShutdown,
  closeHealthServer,
  createSimpleHealthServer,
  runServiceMain,
} from '@arbitrage/core';
import type { CrossRegionHealthConfig } from '@arbitrage/core';
import {
  createCircuitBreakerApiHandler,
} from './api';

const logger = createLogger('execution-engine');

// Health check port (default: 3005)
const HEALTH_CHECK_PORT = parseInt(process.env.HEALTH_CHECK_PORT || process.env.EXECUTION_ENGINE_PORT || '3005', 10);

let healthServer: Server | null = null;

/**
 * Parse simulation configuration from environment variables.
 * Returns undefined if simulation is not enabled.
 *
 * Exported for unit testing -- not part of the public service API.
 */
export function getSimulationConfigFromEnv(): SimulationConfig | undefined {
  const enabled = process.env.EXECUTION_SIMULATION_MODE === 'true';

  if (!enabled) {
    return undefined;
  }

  return {
    enabled: true,
    successRate: parseFloat(process.env.EXECUTION_SIMULATION_SUCCESS_RATE || '0.85'),
    executionLatencyMs: parseInt(process.env.EXECUTION_SIMULATION_LATENCY_MS || '500', 10),
    gasUsed: parseInt(process.env.EXECUTION_SIMULATION_GAS_USED || '200000', 10),
    gasCostMultiplier: parseFloat(process.env.EXECUTION_SIMULATION_GAS_COST_MULTIPLIER || '0.1'),
    profitVariance: parseFloat(process.env.EXECUTION_SIMULATION_PROFIT_VARIANCE || '0.2'),
    logSimulatedExecutions: process.env.EXECUTION_SIMULATION_LOG !== 'false'
  };
}

/**
 * Parse circuit breaker configuration from environment variables (Phase 1.3).
 *
 * Environment Variables:
 * - CIRCUIT_BREAKER_ENABLED: Whether circuit breaker is enabled (default: true)
 * - CIRCUIT_BREAKER_FAILURE_THRESHOLD: Consecutive failures before tripping (default: 5)
 * - CIRCUIT_BREAKER_COOLDOWN_MS: Cooldown period in ms (default: 300000 = 5 min)
 * - CIRCUIT_BREAKER_HALF_OPEN_ATTEMPTS: Max attempts in HALF_OPEN (default: 1)
 */
/**
 * Exported for unit testing -- not part of the public service API.
 */
export function getCircuitBreakerConfigFromEnv() {
  return {
    enabled: process.env.CIRCUIT_BREAKER_ENABLED !== 'false', // Default: true
    failureThreshold: parseInt(process.env.CIRCUIT_BREAKER_FAILURE_THRESHOLD || '5', 10),
    cooldownPeriodMs: parseInt(process.env.CIRCUIT_BREAKER_COOLDOWN_MS || '300000', 10),
    halfOpenMaxAttempts: parseInt(process.env.CIRCUIT_BREAKER_HALF_OPEN_ATTEMPTS || '1', 10),
  };
}

/**
 * Parse standby configuration from environment variables (ADR-007).
 *
 * Uses shared getCrossRegionEnvConfig for common cross-region fields (S-6).
 * Execution-engine-specific fields (queue pause, standby flag) are parsed here.
 */
/**
 * Exported for unit testing -- not part of the public service API.
 */
export function getStandbyConfigFromEnv() {
  const isStandby = process.env.IS_STANDBY === 'true';
  const queuePausedOnStart = process.env.QUEUE_PAUSED_ON_START === 'true';

  // Shared cross-region health settings (S-6 consolidation)
  const crossRegion = getCrossRegionEnvConfig('execution-engine');

  return {
    isStandby,
    queuePausedOnStart,
    regionId: crossRegion.regionId,
    serviceName: crossRegion.serviceName,
    healthCheckIntervalMs: crossRegion.healthCheckIntervalMs,
    failoverThreshold: crossRegion.failoverThreshold,
    failoverTimeoutMs: crossRegion.failoverTimeoutMs,
    leaderHeartbeatIntervalMs: crossRegion.leaderHeartbeatIntervalMs,
    leaderLockTtlMs: crossRegion.leaderLockTtlMs,
  };
}

/**
 * Create the execution engine health server using shared createSimpleHealthServer.
 *
 * Endpoints provided:
 * - GET /health — Health check with detailed status (via healthCheck callback)
 * - GET /ready — Readiness check (via readyCheck callback)
 * - GET /stats — Execution statistics (via additionalRoutes)
 * - GET / — Service info (auto-generated by createSimpleHealthServer)
 * - GET /circuit-breaker — Circuit breaker status (via additionalRoutes)
 * - POST /circuit-breaker/close — Force close circuit breaker
 * - POST /circuit-breaker/open — Force open circuit breaker
 */
// Cached Redis health status to avoid blocking health checks with ping on every request
let cachedRedisHealthy = true;
let redisHealthCheckInterval: NodeJS.Timeout | null = null;

function startRedisHealthMonitor(engine: ExecutionEngineService): void {
  // Check Redis health every 10 seconds and cache the result
  redisHealthCheckInterval = setInterval(async () => {
    cachedRedisHealthy = await engine.isRedisHealthy();
  }, 10_000);
  // Initial check
  engine.isRedisHealthy().then(healthy => { cachedRedisHealthy = healthy; }).catch(() => { cachedRedisHealthy = false; });
}

function createHealthServer(engine: ExecutionEngineService): Server {
  const circuitBreakerHandler = createCircuitBreakerApiHandler(engine);

  return createSimpleHealthServer({
    port: HEALTH_CHECK_PORT,
    serviceName: 'execution-engine',
    logger,
    description: 'Arbitrage Execution Engine Service',
    healthCheck: () => {
      const isRunning = engine.isRunning();
      const stats = engine.getStats();
      const healthyProviders = engine.getHealthyProvidersCount();
      const isSimulation = engine.getIsSimulationMode();

      const status = !isRunning ? 'unhealthy' :
                    (!cachedRedisHealthy) ? 'degraded' :
                    (healthyProviders === 0 && !isSimulation) ? 'degraded' : 'healthy';

      return {
        status,
        simulationMode: isSimulation,
        redisConnected: cachedRedisHealthy,
        healthyProviders,
        queueSize: engine.getQueueSize(),
        activeExecutions: engine.getActiveExecutionsCount(),
        executionAttempts: stats.executionAttempts,
        successRate: stats.executionAttempts > 0
          ? (stats.successfulExecutions / stats.executionAttempts * 100).toFixed(2) + '%'
          : 'N/A',
        uptime: process.uptime(),
        memoryMB: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
      };
    },
    readyCheck: () => engine.isRunning(),
    additionalRoutes: {
      '/stats': (_req: IncomingMessage, res: ServerResponse) => {
        const stats = engine.getStats();
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ service: 'execution-engine', stats }));
      },
      '/circuit-breaker': circuitBreakerHandler,
      '/circuit-breaker/close': circuitBreakerHandler,
      '/circuit-breaker/open': circuitBreakerHandler,
    },
  });
}

async function main() {
  try {
    const simulationConfig = getSimulationConfigFromEnv();
    const standbyConfig = getStandbyConfigFromEnv();
    const circuitBreakerConfig = getCircuitBreakerConfigFromEnv();

    logger.info(`Starting Execution Engine Service on port ${HEALTH_CHECK_PORT}`);
    logger.debug('Execution engine startup config', {
      simulationMode: simulationConfig?.enabled ?? false,
      isStandby: standbyConfig.isStandby,
      queuePausedOnStart: standbyConfig.queuePausedOnStart,
      regionId: standbyConfig.regionId,
      healthCheckPort: HEALTH_CHECK_PORT,
      circuitBreakerEnabled: circuitBreakerConfig.enabled,
      circuitBreakerThreshold: circuitBreakerConfig.failureThreshold,
    });

    // Generate unique instance ID
    const instanceId = `execution-engine-${standbyConfig.regionId}-${process.env.HOSTNAME || 'local'}-${Date.now()}`;

    const engine = new ExecutionEngineService({
      simulationConfig,
      standbyConfig: {
        isStandby: standbyConfig.isStandby,
        queuePausedOnStart: standbyConfig.queuePausedOnStart,
        activationDisablesSimulation: true, // Default behavior for standby activation
        regionId: standbyConfig.regionId
      },
      circuitBreakerConfig,
    });

    // Initialize CrossRegionHealthManager for cross-region failover (ADR-007)
    // NOTE: Executor only initializes CrossRegionHealthManager when running as standby,
    // unlike Coordinator which always initializes it (coordinator participates in leader
    // election regardless of standby status). This design choice avoids unnecessary
    // overhead for primary executors while ensuring coordinators can always failover.
    let crossRegionManager: ReturnType<typeof getCrossRegionHealthManager> | null = null;
    if (standbyConfig.isStandby) {
      const crossRegionConfig: CrossRegionHealthConfig = {
        instanceId,
        regionId: standbyConfig.regionId,
        serviceName: standbyConfig.serviceName,
        healthCheckIntervalMs: standbyConfig.healthCheckIntervalMs,
        failoverThreshold: standbyConfig.failoverThreshold,
        failoverTimeoutMs: standbyConfig.failoverTimeoutMs,
        leaderHeartbeatIntervalMs: standbyConfig.leaderHeartbeatIntervalMs,
        leaderLockTtlMs: standbyConfig.leaderLockTtlMs,
        canBecomeLeader: true, // Standby executor can become leader on failover
        isStandby: standbyConfig.isStandby
      };

      crossRegionManager = getCrossRegionHealthManager(crossRegionConfig);

      // Wire up failover events
      // P2-4 FIX: Wrap async handler in try-catch to prevent unhandled rejection
      crossRegionManager.on('activateStandby', async (event: { failedRegion: string; timestamp: number }) => {
        try {
          logger.warn('Standby activation triggered by CrossRegionHealthManager', {
            failedRegion: event.failedRegion
          });
          const activated = await engine.activate();
          if (activated) {
            logger.info('Executor successfully activated');
          } else {
            logger.error('Failed to activate executor');
          }
        } catch (error) {
          logger.error('Error during standby activation', {
            error: error instanceof Error ? error.message : String(error),
            failedRegion: event.failedRegion
          });
        }
      });

      crossRegionManager.on('failoverStarted', (event) => {
        logger.warn('Failover started', {
          sourceRegion: event.sourceRegion,
          targetRegion: event.targetRegion,
          services: event.services
        });
      });

      crossRegionManager.on('failoverCompleted', (event) => {
        logger.info('Failover completed', {
          sourceRegion: event.sourceRegion,
          targetRegion: event.targetRegion,
          durationMs: event.durationMs
        });
      });

      // Start cross-region health manager
      await crossRegionManager.start();
      logger.info('CrossRegionHealthManager started for standby executor');
    }

    // Start health server first
    healthServer = createHealthServer(engine);
    startRedisHealthMonitor(engine);

    await engine.start();

    // Graceful shutdown with shared bootstrap utility
    setupServiceShutdown({
      logger,
      serviceName: 'Execution Engine',
      onShutdown: async () => {
        // Stop cross-region health manager if running
        // P1-2 FIX: Remove event listeners before destroying manager to prevent memory leak
        if (crossRegionManager) {
          crossRegionManager.removeAllListeners();
          await resetCrossRegionHealthManager();
        }

        if (redisHealthCheckInterval) {
          clearInterval(redisHealthCheckInterval);
          redisHealthCheckInterval = null;
        }
        await closeHealthServer(healthServer);
        await engine.stop();
      },
    });

    logger.info('Execution Engine Service is running');

  } catch (error) {
    logger.error('Failed to start Execution Engine Service', { error });
    process.exit(1);
  }
}

runServiceMain({ main, serviceName: 'Execution Engine Service', logger });
