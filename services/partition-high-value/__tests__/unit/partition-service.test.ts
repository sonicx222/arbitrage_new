/**
 * Unit Tests for P3 High-Value Partition Service
 *
 * Tests partition-specific configuration, exports, and service setup.
 * The JEST_WORKER_ID guard in index.ts prevents auto-start during import.
 *
 * Common test blocks are generated by the shared partition test factory.
 * P3-specific tests are defined inline below.
 *
 * P3 High-Value Partition:
 * - Chains: Ethereum (1), zkSync Era (324), Linea (59144)
 * - Region: Oracle Cloud US-East (us-east1)
 * - Port: 3003
 * - Health Check Interval: 30s (longer for Ethereum's ~12s blocks)
 */

import {
  MockUnifiedChainDetector,
  createMockLogger,
  createMockStateManager,
  createCoreMocks,
  createConfigMocks,
} from '@arbitrage/test-utils/mocks/partition-service.mock';
import { generatePartitionUnitTests } from '@arbitrage/test-utils/partition-test-factory';

// =============================================================================
// Mocks - Must be defined before imports
// =============================================================================

const mockLogger = createMockLogger();
const mockStateManager = createMockStateManager();

// FIX #6: Use shared createCoreMocks() to replace ~148 lines of inline mock definitions
jest.mock('@arbitrage/core', () => createCoreMocks(mockLogger, mockStateManager));

// Mock @arbitrage/config with P3 High-Value partition configuration
jest.mock('@arbitrage/config', () => createConfigMocks({
  partitionId: 'high-value',
  name: 'High Value Chains',
  chains: ['ethereum', 'zksync', 'linea'],
  region: 'us-east1',
  provider: 'oracle',
  resourceProfile: 'heavy',
  priority: 2,
  maxMemoryMB: 768,
  healthCheckIntervalMs: 30000,
  failoverTimeoutMs: 60000,
  extra: {
    standbyRegion: 'eu-west1',
    standbyProvider: 'gcp',
  },
  chainsSubset: ['ethereum', 'zksync', 'linea'],
}));

// Use shared MockUnifiedChainDetector from @arbitrage/test-utils
jest.mock('@arbitrage/unified-detector', () => ({
  UnifiedChainDetector: MockUnifiedChainDetector,
}));

// =============================================================================
// Common Tests (generated by partition test factory)
// =============================================================================

generatePartitionUnitTests({
  partitionId: 'high-value',
  partitionLabel: 'P3',
  partitionName: 'High-Value',
  chains: ['ethereum', 'zksync', 'linea'],
  defaultPort: 3003,
  region: 'us-east1',
  exportPrefix: 'P3',
  importModule: () => import('../../src/index'),
  mockLogger,
  // P3 has custom env var and process handler tests that test through module import
  skipBlocks: ['envVarHandling', 'processHandlerCleanup'],
});

// =============================================================================
// P3-Specific: Environment Variable Handling (tests via module import)
// =============================================================================

describe('P3 Environment Variable Handling', () => {
  const originalEnv = process.env;
  let cleanupFn: (() => void) | null = null;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...originalEnv, JEST_WORKER_ID: 'test', NODE_ENV: 'test' };
    delete process.env.REGION_ID;
    delete process.env.INSTANCE_ID;
    delete process.env.ENABLE_CROSS_REGION_HEALTH;
  });

  afterEach(async () => {
    // BUG-FIX: Clean up process handlers with error handling to prevent memory leaks
    try {
      if (cleanupFn) {
        cleanupFn();
      }
    } catch (error) {
      // Log but don't fail test if cleanup throws
      console.warn('Cleanup function failed:', error);
    } finally {
      cleanupFn = null;
      // We do NOT use removeAllListeners() as it can remove Jest's own handlers for
      // uncaughtException and unhandledRejection, causing test framework issues.
      // The cleanupFn from setupProcessHandlers uses process.off() with specific handler
      // references, so it correctly removes only the handlers registered by that module.
    }
    process.env = originalEnv;
  });

  it('should use PARTITION_CHAINS env var when provided', async () => {
    process.env.PARTITION_CHAINS = 'ethereum,zksync';

    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.chains).toEqual(['ethereum', 'zksync']);
  });

  it('should use HEALTH_CHECK_PORT env var when provided', async () => {
    process.env.HEALTH_CHECK_PORT = '4003';

    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.healthCheckPort).toBe(4003);
  });

  it('should use default port when HEALTH_CHECK_PORT is invalid', async () => {
    process.env.HEALTH_CHECK_PORT = 'invalid';

    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.healthCheckPort).toBe(3003);
  });

  it('should use INSTANCE_ID env var when provided', async () => {
    process.env.INSTANCE_ID = 'p3-high-value-custom-123';

    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.instanceId).toBe('p3-high-value-custom-123');
  });

  it('should use REGION_ID env var when provided', async () => {
    process.env.REGION_ID = 'eu-west1';

    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.regionId).toBe('eu-west1');
  });

  it('should disable cross-region health when ENABLE_CROSS_REGION_HEALTH is false', async () => {
    process.env.ENABLE_CROSS_REGION_HEALTH = 'false';

    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.enableCrossRegionHealth).toBe(false);
  });

  it('should enable cross-region health by default', async () => {
    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.enableCrossRegionHealth).toBe(true);
  });

  it('should generate default instance ID when not provided', async () => {
    delete process.env.INSTANCE_ID;

    const { config, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(config.instanceId).toMatch(/^high-value-/);
  });
});

// =============================================================================
// P3-Specific: Typed Environment Configuration (envConfig)
// =============================================================================

describe('P3 Typed Environment Configuration (envConfig)', () => {
  const originalEnv = process.env;
  let cleanupFn: (() => void) | null = null;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...originalEnv, JEST_WORKER_ID: 'test', NODE_ENV: 'test' };
    delete process.env.REGION_ID;
    delete process.env.INSTANCE_ID;
    delete process.env.ENABLE_CROSS_REGION_HEALTH;
  });

  afterEach(() => {
    try {
      if (cleanupFn) {
        cleanupFn();
      }
    } catch {
      // Ignore cleanup errors
    } finally {
      cleanupFn = null;
    }
    process.env = originalEnv;
  });

  it('should export envConfig with typed configuration', async () => {
    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(envConfig).toBeDefined();
    expect(typeof envConfig.enableCrossRegionHealth).toBe('boolean');
    expect(typeof envConfig.nodeEnv).toBe('string');
  });

  it('should include rpcUrls for all P3 chains', async () => {
    process.env.ETHEREUM_RPC_URL = 'https://custom-eth.com';
    process.env.ZKSYNC_RPC_URL = 'https://custom-zksync.com';
    process.env.LINEA_RPC_URL = 'https://custom-linea.com';

    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(envConfig.rpcUrls).toBeDefined();
    expect(envConfig.rpcUrls.ethereum).toBe('https://custom-eth.com');
    expect(envConfig.rpcUrls.zksync).toBe('https://custom-zksync.com');
    expect(envConfig.rpcUrls.linea).toBe('https://custom-linea.com');
  });

  it('should include wsUrls for all P3 chains', async () => {
    process.env.ETHEREUM_WS_URL = 'wss://custom-eth.com';
    process.env.ZKSYNC_WS_URL = 'wss://custom-zksync.com';
    process.env.LINEA_WS_URL = 'wss://custom-linea.com';

    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(envConfig.wsUrls).toBeDefined();
    expect(envConfig.wsUrls.ethereum).toBe('wss://custom-eth.com');
    expect(envConfig.wsUrls.zksync).toBe('wss://custom-zksync.com');
    expect(envConfig.wsUrls.linea).toBe('wss://custom-linea.com');
  });

  it('should have undefined rpcUrls when env vars not set', async () => {
    delete process.env.ETHEREUM_RPC_URL;
    delete process.env.ZKSYNC_RPC_URL;
    delete process.env.LINEA_RPC_URL;

    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(envConfig.rpcUrls.ethereum).toBeUndefined();
    expect(envConfig.rpcUrls.zksync).toBeUndefined();
    expect(envConfig.rpcUrls.linea).toBeUndefined();
  });

  it('should reflect NODE_ENV in envConfig', async () => {
    process.env.NODE_ENV = 'production';

    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(envConfig.nodeEnv).toBe('production');
  });
});

// =============================================================================
// P3-Specific: High-Value Chain Characteristics
// =============================================================================

describe('P3 High-Value Chain Characteristics', () => {
  // Reset modules before this test block to get fresh mock state
  beforeAll(() => {
    jest.resetModules();
  });

  it('should have Ethereum (chain ID 1) in the partition', async () => {
    const { config } = await import('../../src/index');
    expect(config.chains).toContain('ethereum');
  });

  it('should have zkSync Era (chain ID 324) for ZK rollup arbitrage', async () => {
    const { config } = await import('../../src/index');
    expect(config.chains).toContain('zksync');
  });

  it('should have Linea (chain ID 59144) for Consensys ZK rollup', async () => {
    const { config } = await import('../../src/index');
    expect(config.chains).toContain('linea');
  });

  it('should use us-east1 region (Oracle Cloud US-East)', async () => {
    // Verify via the exported config from index.ts (avoids mock state issues)
    const { P3_REGION, config } = await import('../../src/index');
    expect(P3_REGION).toBe('us-east1');
    expect(config.regionId).toBe('us-east1');
  });

  it('should verify partition configuration via exported constants', async () => {
    // The partition details (provider, healthCheckIntervalMs, standbyRegion)
    // are verified through the index module's exported values
    const { P3_PARTITION_ID, P3_CHAINS, P3_REGION } = await import('../../src/index');
    expect(P3_PARTITION_ID).toBe('high-value');
    expect(P3_CHAINS).toEqual(expect.arrayContaining(['ethereum', 'zksync', 'linea']));
    expect(P3_REGION).toBe('us-east1');
  });
});
