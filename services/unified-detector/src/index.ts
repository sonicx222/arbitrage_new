/**
 * Unified Detector Service Entry Point
 *
 * Multi-chain detector that runs multiple blockchain detectors
 * in a single process based on partition configuration.
 *
 * Environment Variables:
 * - PARTITION_ID: Partition to run (default: asia-fast)
 * - PARTITION_CHAINS: Override chains (comma-separated)
 * - REDIS_URL: Redis connection URL
 * - LOG_LEVEL: Logging level (default: info)
 * - REGION_ID: Region for cross-region health reporting
 * - HEALTH_CHECK_PORT: HTTP health check port (default: 3001)
 *
 * @see ADR-003: Partitioned Chain Detectors
 */

import { IncomingMessage, ServerResponse, Server } from 'http';
import { UnifiedChainDetector, UnifiedDetectorConfig } from './unified-detector';
import {
  createLogger,
  parsePort,
  getRedisStreamsClient,
  createSimpleHealthServer,
  setupServiceShutdown,
  closeHealthServer,
  runServiceMain,
  RedisStreamsClient,
} from '@arbitrage/core';
import { getPartition } from '@arbitrage/config';
import { DEFAULT_HEALTH_CHECK_PORT } from './constants';
import { OpportunityPublisher } from './publishers';

// =============================================================================
// Configuration
// =============================================================================

const logger = createLogger('unified-detector:main');

// Store server reference for graceful shutdown
let healthServer: Server | null = null;

// Store publisher and streams client references for lifecycle management
let opportunityPublisher: OpportunityPublisher | null = null;
let streamsClient: RedisStreamsClient | null = null;

// FIX Inconsistency 6.2: Use parsePort for consistent port validation
const healthCheckPort = parsePort(process.env.HEALTH_CHECK_PORT, DEFAULT_HEALTH_CHECK_PORT, logger);

// Get region from partition config for consistent health response
const partitionConfig = process.env.PARTITION_ID ? getPartition(process.env.PARTITION_ID) : null;
const regionId = process.env.REGION_ID || partitionConfig?.region || 'asia-southeast1';

const config: UnifiedDetectorConfig = {
  partitionId: process.env.PARTITION_ID,
  chains: process.env.PARTITION_CHAINS?.split(',').map(c => c.trim()),
  instanceId: process.env.INSTANCE_ID || `unified-${process.env.HOSTNAME || 'local'}-${Date.now()}`,
  regionId,
  enableCrossRegionHealth: process.env.ENABLE_CROSS_REGION_HEALTH !== 'false',
  healthCheckPort
};

// =============================================================================
// Service Instance
// =============================================================================

const detector = new UnifiedChainDetector(config);

// =============================================================================
// HTTP Health Check Server
// FIX Inconsistency 6.1: Aligned response format with createPartitionHealthServer
// Uses shared createSimpleHealthServer() utility from @arbitrage/core
// =============================================================================

/** Health cache TTL in milliseconds (matches partition-service-utils) */
const HEALTH_CACHE_TTL_MS = 1000;

interface HealthCacheEntry {
  data: Awaited<ReturnType<typeof detector.getPartitionHealth>>;
  timestamp: number;
}

let healthCache: HealthCacheEntry | null = null;

function getHealthFromCache(): HealthCacheEntry['data'] | null {
  if (!healthCache) return null;
  if (Date.now() - healthCache.timestamp > HEALTH_CACHE_TTL_MS) {
    healthCache = null;
    return null;
  }
  return healthCache.data;
}

function setHealthCache(data: HealthCacheEntry['data']): void {
  healthCache = { data, timestamp: Date.now() };
}

/**
 * Create health server using shared createSimpleHealthServer utility.
 *
 * Endpoints provided:
 * - GET /health — Cached partition health (1s TTL) with chain/region data
 * - GET /ready — Readiness check with chain list
 * - GET /stats — Partition statistics
 * - GET / — Service info with partition metadata (auto-generated by createSimpleHealthServer)
 */
function createHealthServer(port: number): Server {
  const serviceName = `unified-detector-${config.partitionId || 'default'}`;

  return createSimpleHealthServer({
    port,
    serviceName,
    logger,
    description: `${config.partitionId || 'unified'} Partition Detector`,
    healthCheck: async () => {
      // PERF-FIX: Use cached health data if available and fresh
      let health = getHealthFromCache();
      if (!health) {
        health = await detector.getPartitionHealth();
        setHealthCache(health);
      }

      return {
        status: health.status,
        // Preserve explicit statusCode mapping (healthy/degraded=200, other=503)
        statusCode: health.status === 'healthy' || health.status === 'degraded' ? 200 : 503,
        partitionId: health.partitionId,
        chains: Array.from(health.chainHealth.keys()),
        healthyChains: detector.getHealthyChains(),
        uptime: health.uptimeSeconds,
        eventsProcessed: health.totalEventsProcessed,
        memoryMB: Math.round(health.memoryUsage / 1024 / 1024),
        region: regionId,
      };
    },
    readyCheck: () => detector.isRunning(),
    additionalRoutes: {
      '/stats': (_req: IncomingMessage, res: ServerResponse) => {
        try {
          const stats = detector.getStats();
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            service: serviceName,
            partitionId: stats.partitionId,
            chains: stats.chains,
            totalEvents: stats.totalEventsProcessed,
            totalOpportunities: stats.totalOpportunitiesFound,
            uptimeSeconds: stats.uptimeSeconds,
            memoryMB: stats.memoryUsageMB,
            chainStats: Object.fromEntries(stats.chainStats)
          }));
        } catch (error) {
          logger.error('Stats endpoint error', { error: (error as Error).message });
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            service: serviceName,
            status: 'error',
          }));
        }
      },
    },
  });
}

// =============================================================================
// Event Handlers
// =============================================================================

// NOTE: Price update event logging removed - fires 100s-1000s times/sec
// Use metrics/monitoring for price update visibility if needed
// detector.on('priceUpdate', ...) intentionally not logged

detector.on('opportunity', (opp) => {
  logger.info('Arbitrage opportunity detected', {
    id: opp.id,
    type: opp.type,
    buyDex: opp.buyDex,
    sellDex: opp.sellDex,
    profit: opp.expectedProfit,
    percentage: opp.profitPercentage?.toFixed(2) + '%'  // profitPercentage is already a percentage value
  });

  // Publish opportunity to Redis Streams for Coordinator/Execution Engine
  // FIX P0: Fire-and-forget pattern with explicit error handling
  // - EventEmitter doesn't await async handlers, causing unhandled rejections
  // - Using .catch() ensures errors are logged, not thrown as unhandled rejections
  // - This is intentional: we don't want to block the detector's event loop
  if (opportunityPublisher) {
    opportunityPublisher.publish(opp).catch((error) => {
      logger.error('Failed to publish opportunity (fire-and-forget)', {
        opportunityId: opp.id,
        error: (error as Error).message,
      });
    });
  }
});

detector.on('chainError', ({ chainId, error }) => {
  logger.error(`Chain error: ${chainId}`, { error: error.message });
});

detector.on('failoverEvent', (event) => {
  logger.warn('Failover event received', event);
});

// =============================================================================
// Graceful Shutdown (uses shared setupServiceShutdown from @arbitrage/core)
// =============================================================================

// =============================================================================
// Main Entry Point
// =============================================================================

async function main(): Promise<void> {
  logger.info('Starting Unified Detector Service', {
    partitionId: config.partitionId,
    chains: config.chains,
    region: regionId,
    nodeVersion: process.version,
    pid: process.pid
  });

  try {
    // Initialize Redis Streams client for opportunity publishing
    streamsClient = await getRedisStreamsClient();
    logger.info('Redis Streams client initialized for opportunity publishing');

    // Initialize opportunity publisher
    opportunityPublisher = new OpportunityPublisher({
      logger,
      streamsClient,
      partitionId: config.partitionId,
    });
    logger.info('OpportunityPublisher initialized');

    // Start health check server first
    healthServer = createHealthServer(config.healthCheckPort ?? DEFAULT_HEALTH_CHECK_PORT);

    // Start detector
    await detector.start();

    // Graceful shutdown with shared bootstrap utility
    setupServiceShutdown({
      logger,
      serviceName: 'Unified Detector',
      onShutdown: async () => {
        // BUG-FIX: Clear health cache to prevent stale data on restart scenarios
        healthCache = null;

        // Close health server first (with timeout via shared utility)
        await closeHealthServer(healthServer);

        // BUG-FIX: Remove event listeners from detector to prevent memory leaks
        // This is important if the process doesn't exit (e.g., in tests)
        detector.removeAllListeners();

        await detector.stop();

        // Log publisher stats before cleanup
        if (opportunityPublisher) {
          const stats = opportunityPublisher.getStats();
          logger.info('OpportunityPublisher stats at shutdown', {
            published: stats.published,
            failed: stats.failed,
          });
          opportunityPublisher = null;
        }

        // FIX P3: Clear streamsClient reference (singleton cleanup happens in detector.stop())
        // Note: getRedisStreamsClient() returns a singleton shared by both index.ts and
        // UnifiedChainDetector. The actual disconnect is handled by detector.stop() which
        // calls streamsClient.disconnect(). We just clear our reference here.
        // Setting to null prevents accidental use after shutdown.
        streamsClient = null;
      },
    });

    logger.info('Unified Detector Service started successfully', {
      partitionId: detector.getPartitionId(),
      chains: detector.getChains(),
      healthyChains: detector.getHealthyChains()
    });

  } catch (error) {
    logger.error('Failed to start Unified Detector Service', { error });

    // BUG-4.2-FIX: Await health server close before exiting
    await closeHealthServer(healthServer, 1000);

    process.exit(1);
  }
}

runServiceMain({ main, serviceName: 'Unified Detector Service', logger });

// =============================================================================
// Exports (re-export from exports.ts for backwards compatibility)
// =============================================================================

// NOTE: For library imports, use the package which points to exports.ts
// This file (index.ts) is the SERVICE entry point and should only be run directly.
// Re-exports are kept here for any code that directly imports from index.ts
export * from './exports';
