/**
 * Unit Tests for P1 Asia-Fast Partition Service
 *
 * Tests partition-specific configuration, exports, and service setup.
 * The JEST_WORKER_ID guard in index.ts prevents auto-start during import.
 *
 * Common test blocks are generated by the shared partition test factory.
 * P1-specific tests (Typed Environment Configuration) are defined inline below.
 */

import {
  MockUnifiedChainDetector,
  createMockLogger,
  createMockStateManager,
  createCoreMocks,
  createConfigMocks,
} from '@arbitrage/test-utils/mocks/partition-service.mock';
import { generatePartitionUnitTests } from '@arbitrage/test-utils/partition-test-factory';

// =============================================================================
// Mocks - Must be defined before imports
// =============================================================================

const mockLogger = createMockLogger();
const mockStateManager = createMockStateManager();

// FIX #6: Use shared createCoreMocks() to replace ~148 lines of inline mock definitions
jest.mock('@arbitrage/core', () => createCoreMocks(mockLogger, mockStateManager));

// Mock sub-entry point @arbitrage/core/partition used by source imports.
// Uses plain functions (closures) instead of jest.fn() so resetMocks: true
// does not clear their implementations between tests.
jest.mock('@arbitrage/core/partition', () => {
  const PORTS: Record<string, number> = { 'asia-fast': 3001, 'l2-turbo': 3002, 'high-value': 3003, 'solana-native': 3004 };
  const SERVICE_NAMES: Record<string, string> = { 'asia-fast': 'partition-asia-fast', 'l2-turbo': 'partition-l2-turbo', 'high-value': 'partition-high-value', 'solana-native': 'partition-solana' };

  // Track calls for assertion without jest.fn (immune to resetMocks)
  const _calls: any[][] = [];

  function createPartitionEntry(
    partitionId: string,
    createDetector: (cfg: unknown) => unknown,
    hooks?: { onStarted?: Function; onStartupError?: Function; additionalCleanup?: () => void }
  ) {
    _calls.push([partitionId, createDetector, hooks]);
    const { getPartition } = require('@arbitrage/config');
    const partitionConfig = getPartition(partitionId);
    const chains: string[] = partitionConfig?.chains ?? [];
    const region: string = partitionConfig?.region ?? 'us-east1';
    const defaultPort = PORTS[partitionId] ?? 3000;
    const serviceName = SERVICE_NAMES[partitionId] ?? `partition-${partitionId}`;

    const envConfig = {
      redisUrl: process.env.REDIS_URL,
      partitionChains: process.env.PARTITION_CHAINS,
      healthCheckPort: process.env.HEALTH_CHECK_PORT,
      instanceId: process.env.INSTANCE_ID,
      regionId: process.env.REGION_ID,
      enableCrossRegionHealth: process.env.ENABLE_CROSS_REGION_HEALTH !== 'false',
      nodeEnv: process.env.NODE_ENV ?? 'development',
      rpcUrls: Object.fromEntries(chains.map((c: string) => [c, process.env[`${c.toUpperCase()}_RPC_URL`]])),
      wsUrls: Object.fromEntries(chains.map((c: string) => [c, process.env[`${c.toUpperCase()}_WS_URL`]])),
    };

    const instanceId = envConfig.instanceId ?? `${partitionId}-${process.env.HOSTNAME ?? 'local'}-${Date.now()}`;
    const healthCheckPort = envConfig.healthCheckPort ? (parseInt(envConfig.healthCheckPort, 10) || defaultPort) : defaultPort;

    let resolvedChains = [...chains];
    if (envConfig.partitionChains) {
      resolvedChains = envConfig.partitionChains.split(',').map((c: string) => c.trim().toLowerCase());
    }

    const detectorConfig = {
      partitionId, chains: resolvedChains, instanceId,
      regionId: envConfig.regionId ?? region,
      enableCrossRegionHealth: envConfig.enableCrossRegionHealth ?? true,
      healthCheckPort,
    };

    const detector = createDetector(detectorConfig);

    return {
      detector, config: detectorConfig, partitionId, chains, region,
      cleanupProcessHandlers: () => {},
      envConfig,
      runner: { detector, start: async () => {}, getState: () => 'idle', cleanup: () => {}, healthServer: { current: null } },
      serviceConfig: { partitionId, serviceName, defaultChains: chains, defaultPort, region, provider: partitionConfig?.provider ?? 'oracle' },
      logger: mockLogger,
    };
  }
  // Attach _calls for test assertions
  (createPartitionEntry as any)._calls = _calls;

  return {
    createPartitionEntry,
    parsePartitionEnvironmentConfig: () => ({}),
    validatePartitionEnvironmentConfig: () => {},
    generateInstanceId: (pid: string, id?: string) => id ?? `${pid}-local-${Date.now()}`,
    exitWithConfigError: (msg: string) => { throw new Error(`Config error: ${msg}`); },
    PARTITION_PORTS: PORTS,
    PARTITION_SERVICE_NAMES: SERVICE_NAMES,
  };
});

// Mock @arbitrage/config with Asia-Fast partition configuration
jest.mock('@arbitrage/config', () => createConfigMocks({
  partitionId: 'asia-fast',
  name: 'Asia Fast Chains',
  chains: ['bsc', 'polygon', 'avalanche', 'fantom'],
  region: 'asia-southeast1',
  provider: 'oracle',
  resourceProfile: 'heavy',
  priority: 1,
  maxMemoryMB: 768,
  healthCheckIntervalMs: 15000,
  failoverTimeoutMs: 60000,
  chainsSubset: ['bsc', 'polygon', 'avalanche', 'fantom'],
}));

// Use shared MockUnifiedChainDetector from @arbitrage/test-utils
jest.mock('@arbitrage/unified-detector', () => ({
  UnifiedChainDetector: MockUnifiedChainDetector,
}));

// =============================================================================
// Common Tests (generated by partition test factory)
// =============================================================================

generatePartitionUnitTests({
  partitionId: 'asia-fast',
  partitionLabel: 'P1',
  partitionName: 'Asia-Fast',
  chains: ['bsc', 'polygon', 'avalanche', 'fantom'],
  defaultPort: 3001,
  region: 'asia-southeast1',
  exportPrefix: 'P1',
  importModule: () => import('../../src/index'),
  mockLogger,
});

// =============================================================================
// P1-Specific: Typed Environment Configuration (Shared Utilities)
// =============================================================================

// Tests for typed environment configuration using shared utilities
describe('Typed Environment Configuration (Shared Utilities)', () => {
  const originalEnv = process.env;
  let cleanupFn: (() => void) | null = null;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...originalEnv, JEST_WORKER_ID: 'test', NODE_ENV: 'test' };
    delete process.env.REGION_ID;
    delete process.env.INSTANCE_ID;
    delete process.env.ENABLE_CROSS_REGION_HEALTH;
  });

  afterEach(() => {
    if (cleanupFn) {
      cleanupFn();
      cleanupFn = null;
    }
    process.env = originalEnv;
  });

  it('should export envConfig with all required properties', async () => {
    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(envConfig).toBeDefined();
    expect(envConfig).toHaveProperty('redisUrl');
    expect(envConfig).toHaveProperty('partitionChains');
    expect(envConfig).toHaveProperty('healthCheckPort');
    expect(envConfig).toHaveProperty('instanceId');
    expect(envConfig).toHaveProperty('regionId');
    expect(envConfig).toHaveProperty('enableCrossRegionHealth');
    expect(envConfig).toHaveProperty('nodeEnv');
    expect(envConfig).toHaveProperty('rpcUrls');
    expect(envConfig).toHaveProperty('wsUrls');
  });

  it('should parse RPC URLs from environment', async () => {
    process.env.BSC_RPC_URL = 'https://custom-bsc-rpc.com';
    process.env.POLYGON_RPC_URL = 'https://custom-polygon-rpc.com';

    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    // Now using Record<string, string | undefined> instead of fixed properties
    expect(envConfig.rpcUrls['bsc']).toBe('https://custom-bsc-rpc.com');
    expect(envConfig.rpcUrls['polygon']).toBe('https://custom-polygon-rpc.com');
  });

  it('should parse WebSocket URLs from environment', async () => {
    process.env.BSC_WS_URL = 'wss://custom-bsc-ws.com';
    process.env.FANTOM_WS_URL = 'wss://custom-fantom-ws.com';

    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    // Now using Record<string, string | undefined> instead of fixed properties
    expect(envConfig.wsUrls['bsc']).toBe('wss://custom-bsc-ws.com');
    expect(envConfig.wsUrls['fantom']).toBe('wss://custom-fantom-ws.com');
  });

  it('should set nodeEnv to test in test environment', async () => {
    const { envConfig, cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    expect(envConfig.nodeEnv).toBe('test');
  });

  it('should call createPartitionEntry during module init', async () => {
    jest.resetModules();
    const { cleanupProcessHandlers } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    const { createPartitionEntry } = jest.requireMock('@arbitrage/core/partition');
    // Plain function tracks calls via _calls array (immune to resetMocks)
    const calls = (createPartitionEntry as any)._calls;
    const matchingCall = calls.find((c: any[]) => c[0] === 'asia-fast');
    expect(matchingCall).toBeDefined();
    expect(typeof matchingCall[1]).toBe('function');
  });

  it('should use createPartitionEntry factory from shared utilities', async () => {
    jest.resetModules();
    const { cleanupProcessHandlers, config } = await import('../../src/index');
    cleanupFn = cleanupProcessHandlers;

    // Verify the factory produced correct config
    expect(config.partitionId).toBe('asia-fast');
    expect(config.instanceId).toMatch(/^asia-fast-/);
  });
});
