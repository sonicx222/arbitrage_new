{"agentId":"CONFIG_AUDITOR","findingId":"CA-001","category":"ROGUE_STREAM","severity":"HIGH","service":"cross-service","affectedFiles":["shared/core/src/resilience/expert-self-healing-manager.ts"],"expected":"Only 12 streams should exist in Redis runtime","actual":"expert-self-healing-manager.ts declares streams not present in runtime: stream:system-failures, stream:system-control, stream:system-scaling","evidence":"Redis has 12 streams (pending-opportunities, system-failover, opportunities, swap-events, service-degradation, dead-letter-queue, whale-alerts, price-updates, execution-results, health, volume-aggregates, execution-requests). Code declares FAILURES: 'stream:system-failures', CONTROL: 'stream:system-control', SCALING: 'stream:system-scaling' at shared/core/src/resilience/expert-self-healing-manager.ts:29-32","recommendation":"Verify if these streams are intended but not yet created, or if they are stale declarations. If stale, remove from expert-self-healing-manager.ts STREAM_NAMES constant. If intended, document their creation lifecycle."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-002","category":"ROGUE_STREAM","severity":"MEDIUM","service":"cross-service","affectedFiles":["shared/core/src/resilience/graceful-degradation.ts"],"expected":"Only documented streams should be referenced","actual":"graceful-degradation.ts references stream:service-recovery which is not present in Redis runtime","evidence":"graceful-degradation.ts:485 publishes to 'stream:service-recovery' but Redis runtime shows no such stream exists. Only stream:service-degradation exists.","recommendation":"Check if stream:service-recovery should be created on-demand or if this is a naming inconsistency. Consider using stream:service-degradation for both degradation and recovery events."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-003","category":"MISSING_SCHEMA","severity":"MEDIUM","service":"cross-service","affectedFiles":["docs/"],"expected":"Stream schema documentation for all 12 discovered streams","actual":"No centralized stream schema documentation found","evidence":"Searched docs/ directory for stream schema definitions. Found stream names in shared/types/src/events.ts but no message schema documentation for: stream:pending-opportunities, stream:system-failover, stream:opportunities, stream:swap-events, stream:service-degradation, stream:dead-letter-queue, stream:whale-alerts, stream:price-updates, stream:execution-results, stream:health, stream:volume-aggregates, stream:execution-requests","recommendation":"Create docs/architecture/REDIS_STREAMS_SCHEMA.md documenting message structure, field types, and examples for each stream. This aids debugging and cross-team integration."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-004","category":"DOC_DRIFT","severity":"LOW","service":"cross-service","affectedFiles":["shared/types/src/events.ts"],"expected":"RedisStreams constant should match runtime reality","actual":"RedisStreams in events.ts declares streams not present in runtime","evidence":"events.ts declares: SERVICE_HEALTH: 'stream:service-health', SERVICE_EVENTS: 'stream:service-events', COORDINATOR_EVENTS: 'stream:coordinator-events', HEALTH_ALERTS: 'stream:health-alerts', CIRCUIT_BREAKER: 'stream:circuit-breaker', FAST_LANE: 'stream:fast-lane', DLQ_ALERTS: 'stream:dlq-alerts', FORWARDING_DLQ: 'stream:forwarding-dlq'. None of these exist in Redis runtime.","recommendation":"Add documentation in events.ts indicating which streams are created on-demand vs pre-created. Consider marking unused/future streams with comments."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-005","category":"GROUP_NAME_MISMATCH","severity":"MEDIUM","service":"execution-engine","affectedFiles":["services/execution-engine/src/consumers/fast-lane.consumer.ts"],"expected":"Consistent consumer group naming across all consumers","actual":"fast-lane.consumer.ts uses 'execution-engine' while opportunity.consumer.ts uses 'execution-engine-group'","evidence":"fast-lane.consumer.ts:101 groupName: 'execution-engine', opportunity.consumer.ts:168 groupName: 'execution-engine-group'. Redis shows execution-requests stream has consumer group 'execution-engine-group' with 7 consumers.","recommendation":"Standardize on 'execution-engine-group' for all execution-engine consumers. Update fast-lane.consumer.ts:101 to use 'execution-engine-group'."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-006","category":"CONFIG_DRIFT","severity":"INFO","service":"cross-service","affectedFiles":["shared/core/src/monitoring/enhanced-health-monitor.ts"],"expected":"Use RedisStreams constants from @arbitrage/types","actual":"enhanced-health-monitor.ts uses hardcoded stream names","evidence":"enhanced-health-monitor.ts:785 await this.publishToStream('stream:health-alerts', alertMessage); enhanced-health-monitor.ts:848 await this.publishToStream('stream:system-commands', cacheMessage); These streams are declared in RedisStreams but not imported.","recommendation":"Import RedisStreams from @arbitrage/types and use RedisStreams.HEALTH_ALERTS and RedisStreams.SYSTEM_COMMANDS instead of magic strings. Improves type safety and refactorability."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-007","category":"CONFIG_DRIFT","severity":"INFO","service":"cross-service","affectedFiles":["shared/core/src/monitoring/cross-region-health.ts"],"expected":"Use RedisStreams constants from @arbitrage/types","actual":"cross-region-health.ts uses hardcoded FAILOVER_STREAM constant","evidence":"cross-region-health.ts:30 const FAILOVER_STREAM = 'stream:system-failover'; This duplicates RedisStreams.SYSTEM_FAILOVER from events.ts.","recommendation":"Import RedisStreams from @arbitrage/types and use RedisStreams.SYSTEM_FAILOVER instead of local constant. Reduces duplication."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-008","category":"CONFIG_DRIFT","severity":"INFO","service":"coordinator","affectedFiles":["services/coordinator/src/coordinator.ts"],"expected":"Use RedisStreams constants consistently","actual":"coordinator.ts uses RedisStreamsClient.STREAMS.* instead of RedisStreams.*","evidence":"coordinator.ts:479 uses RedisStreamsClient.STREAMS.HEALTH instead of RedisStreams.HEALTH. This creates two parallel constant hierarchies for the same values.","recommendation":"Standardize on RedisStreams from @arbitrage/types throughout the codebase. RedisStreamsClient.STREAMS is redundant and creates maintenance burden."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-009","category":"MISSING_ENV_VAR","severity":"MEDIUM","service":"cross-service","affectedFiles":[".env.example"],"expected":"All env vars used in code should be documented in .env.example","actual":"201 env vars used in code but not in .env.example (62% undocumented)","evidence":"Code uses 322 unique env vars, .env.example documents only 121. Notable missing: AB_TESTING_*, BALANCE_MONITOR_*, BCRYPT_ROUNDS, BLOXROUTE_BACKOFF_MULTIPLIER, EXECUTION_HYBRID_*, FLASHBOTS_MAX_RETRIES, JITO_*, KMS_*, NONCE_POOL_*, OTEL_*, PRICE_BATCHER_*, SHUTDOWN_DRAIN_TIMEOUT_MS, STATE_TRANSITION_TIMEOUT_MS, STREAM_SIGNING_KEY, STRICT_CONFIG_VALIDATION, TRADE_LOG_*, WS_MAX_SLOW_RECOVERY_CYCLES. See /tmp/all_env_vars.txt for full list.","recommendation":"Audit all env vars in code and add missing ones to .env.example with comments. This is critical for new developer onboarding and operational deployment."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-010","category":"SCHEMA_DRIFT","severity":"HIGH","service":"cross-service","affectedFiles":["shared/core/src/resilience/expert-self-healing-manager.ts","shared/types/src/events.ts"],"expected":"All declared streams should be either runtime-created or documented as on-demand","actual":"3 streams declared but never created: stream:system-failures, stream:system-control, stream:system-scaling","evidence":"expert-self-healing-manager.ts declares STREAM_NAMES with FAILURES, CONTROL, SCALING streams. Redis runtime shows these never exist. No consumer groups, no messages. Code appears to publish but streams are never consumed.","recommendation":"Either: (1) Create these streams on-demand when expert-self-healing-manager publishes, OR (2) Remove declarations if feature is incomplete. Document lifecycle in ADR or stream schema doc."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-011","category":"NAMING_INCONSISTENCY","severity":"LOW","service":"cross-service","affectedFiles":["shared/core/src/resilience/graceful-degradation.ts"],"expected":"Use 'degradation' consistently in stream names","actual":"Code references both stream:service-degradation and stream:service-recovery","evidence":"graceful-degradation.ts:394,537 publishes to stream:service-degradation. Line 485 publishes to stream:service-recovery. Only stream:service-degradation exists in Redis runtime.","recommendation":"Consolidate on stream:service-degradation for both degradation and recovery events. Use message type field to distinguish event kinds within the stream."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-012","category":"DOC_DRIFT","severity":"MEDIUM","service":"cross-service","affectedFiles":["docs/architecture/ARCHITECTURE_V2.md","docs/CONFIGURATION.md"],"expected":"Documentation should list all 12 active streams with purpose","actual":"No centralized registry of active streams and their consumer groups","evidence":"Redis has 12 streams operational. RedisStreams constant declares 21 streams. No doc maps which services produce/consume which streams. Architecture doc mentions streams but doesn't enumerate them.","recommendation":"Create docs/architecture/REDIS_STREAMS_REGISTRY.md listing: stream name, producer service(s), consumer group(s), message schema reference, creation lifecycle (pre-created vs on-demand)."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-013","category":"PORT_CONFLICT","severity":"HIGH","service":"docker-partitions","affectedFiles":["docker-compose.partitions.yml"],"expected":"All services should use unique external ports matching their documented ports","actual":"All partition services map to internal port 3001, different from documented service ports","evidence":"docker-compose.partitions.yml maps: P1→3001:3001, P2→3002:3001, P3→3003:3001, P4→3004:3001, cross-chain→3006:3001, execution→3005:3001. All use internal port 3001 instead of their documented ports (P1_ASIA_FAST_PORT=3001, P2_L2_TURBO_PORT=3002, etc from .env.example). This means partition services cannot read their own port config correctly inside containers.","recommendation":"Update partition Dockerfiles to read HEALTH_CHECK_PORT env var instead of hardcoded 3001. Or change docker-compose.partitions.yml to match: 3001:3001, 3002:3002, 3003:3003, 3004:3004, 3005:3005, 3006:3006."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-014","category":"ENV_MISMATCH","severity":"MEDIUM","service":"docker-partitions","affectedFiles":["docker-compose.partitions.yml",".env.example"],"expected":"Container HEALTH_CHECK_PORT should match external port mapping","actual":"All partitions use HEALTH_CHECK_PORT=3001 but external ports differ","evidence":"docker-compose.partitions.yml sets HEALTH_CHECK_PORT=3001 for all services (lines 59,95,128,161,188,220). External ports are 3001,3002,3003,3004,3005,3006. If partition code binds to HEALTH_CHECK_PORT inside container, the external mapping mismatches.","recommendation":"Set HEALTH_CHECK_PORT dynamically per service: P1=3001, P2=3002, P3=3003, P4=3004. Or standardize all containers to use port 3001 internally (current state) and document this in ARCHITECTURE.md."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-015","category":"VERSION_MISMATCH","severity":"LOW","service":"cross-service","affectedFiles":["package.json","shared/*/package.json"],"expected":"All shared packages should have consistent dependency versions","actual":"Potential version drift in peer dependencies","evidence":"Multiple shared packages declare peerDependencies on ioredis, ethers, etc. Not verified if versions are consistent across all 7 shared packages. This can cause runtime resolution issues.","recommendation":"Run 'npm run check-deps' or similar to verify peer dependency alignment. Consider moving all peer deps to root package.json with exact versions."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-016","category":"ENV_MISMATCH","severity":"LOW","service":"cross-service","affectedFiles":[".env.example"],"expected":"All feature flags in .env.example should be used in code","actual":"FEATURE_AB_TESTING and FEATURE_COW_BACKRUN declared but unused","evidence":".env.example declares FEATURE_AB_TESTING (line 869) and FEATURE_COW_BACKRUN (line 849) but no process.env.FEATURE_AB_TESTING or process.env.FEATURE_COW_BACKRUN references found in services/ or shared/ TypeScript code. May be used in tests only or stale declarations.","recommendation":"Either: (1) Remove unused feature flags from .env.example if features not implemented, OR (2) Document in comments that they are test-only or future placeholders."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-017","category":"NAMING_INCONSISTENCY","severity":"INFO","service":"coordinator","affectedFiles":["services/coordinator/src/coordinator.ts","shared/core/src/redis/streams.ts"],"expected":"Single source of truth for stream name constants","actual":"Two parallel constant hierarchies: RedisStreams vs RedisStreamsClient.STREAMS","evidence":"coordinator.ts uses RedisStreamsClient.STREAMS.HEALTH (line 479), but shared/types declares RedisStreams.HEALTH. Both resolve to same string but create confusion about which to use.","recommendation":"Deprecate RedisStreamsClient.STREAMS and migrate all code to use RedisStreams from @arbitrage/types. Update coordinator.ts and any other usages."}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-018","category":"CONFIG_DRIFT","severity":"MEDIUM","service":"cross-service","affectedFiles":["shared/core/src/resilience/dual-publish.ts"],"expected":"All stream name references should use RedisStreams constants","actual":"dual-publish.ts documentation uses example stream name as string literal","evidence":"dual-publish.ts:21 JSDoc example: @param streamName - Redis Stream name (e.g., 'stream:failure-events'). Uses hardcoded string instead of referencing RedisStreams constant.","recommendation":"Update JSDoc to reference RedisStreams.* constants in examples. E.g., '@param streamName - Redis Stream name (e.g., RedisStreams.DEAD_LETTER_QUEUE)'"}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-019","category":"SCHEMA_DRIFT","severity":"INFO","service":"cross-service","affectedFiles":["shared/types/src/events.ts"],"expected":"RedisStreams constant should document stream lifecycle","actual":"No indication which streams are pre-created vs on-demand","evidence":"events.ts declares 21 stream names. Runtime shows 12 exist. No documentation indicates which 9 are on-demand, future, or stale. Examples: COORDINATOR_EVENTS, SERVICE_EVENTS, CIRCUIT_BREAKER never appear in runtime.","recommendation":"Add JSDoc comments to each stream constant indicating: (1) pre-created on startup, (2) created on-demand, (3) future/planned, or (4) deprecated. Example: '/** Pre-created by coordinator on startup */ HEALTH: ...'"}
{"agentId":"CONFIG_AUDITOR","findingId":"CA-020","category":"DOC_DRIFT","severity":"HIGH","service":"cross-service","affectedFiles":["docs/architecture/adr/ADR-002-redis-streams.md"],"expected":"ADR-002 should list all operational streams with their purpose","actual":"ADR-002 documents stream swap-events and volume-aggregates but not all 12 operational streams","evidence":"ADR-002:92-95 shows table with 2 streams. Missing documentation for: pending-opportunities, system-failover, opportunities, service-degradation, dead-letter-queue, whale-alerts, price-updates, execution-results, health, execution-requests (10 streams).","recommendation":"Update ADR-002 with complete stream registry table showing: stream name, producer(s), consumer(s), message schema, creation lifecycle. This is the architectural decision doc so it should be authoritative."}
